/** 
 *  codac2_directed_ctc.cpp
 * ----------------------------------------------------------------------------
 *  \date       2024
 *  \author     Simon Rohou
 *  \copyright  Copyright 2024 Codac Team
 *  \license    GNU Lesser General Public License (LGPL)
 */

#include <cassert>
#include "codac2_directed_ctc.h"
#include "codac2_IntervalVector.h"
#include "codac2_IntervalMatrix.h"

using namespace std;
using namespace codac2;

// AddOp (unary operations)

  Interval AddOp::fwd(const Interval& x1)
  {
    return x1;
  }

  void AddOp::bwd([[maybe_unused]] const Interval& y, [[maybe_unused]] Interval& x1)
  { }

  IntervalVector AddOp::fwd(const IntervalVector& x1)
  {
    return x1;
  }

  void AddOp::bwd([[maybe_unused]] const IntervalVector& y, [[maybe_unused]] IntervalVector& x1)
  {
    assert(y.size() == x1.size());
  }

  IntervalMatrix AddOp::fwd(const IntervalMatrix& x1)
  {
    return x1;
  }

  void AddOp::bwd([[maybe_unused]] const IntervalMatrix& y, [[maybe_unused]] IntervalMatrix& x1)
  {
    assert(y.size() == x1.size());
  }


// AddOp (binary operations)

  Interval AddOp::fwd(const Interval& x1, const Interval& x2)
  {
    return x1 + x2;
  }

  void AddOp::bwd(const Interval& y, Interval& x1, Interval& x2)
  {
    bwd_add(y, x1, x2);
  }

  IntervalVector AddOp::fwd(const IntervalVector& x1, const IntervalVector& x2)
  {
    assert(x1.size() == x2.size());
    return x1 + x2;
  }

  void AddOp::bwd(const IntervalVector& y, IntervalVector& x1, IntervalVector& x2)
  {
    assert(y.size() == x1.size() && y.size() == x2.size());
    for(Index i = 0 ; i < y.size() ; i++)
      AddOp::bwd(y[i], x1[i], x2[i]);
  }

  IntervalMatrix AddOp::fwd(const IntervalMatrix& x1, const IntervalMatrix& x2)
  {
    assert(x1.size() == x2.size());
    return x1 + x2;
  }

  void AddOp::bwd(const IntervalMatrix& y, IntervalMatrix& x1, IntervalMatrix& x2)
  {
    assert(y.size() == x1.size() && y.size() == x2.size());
    for(Index i = 0 ; i < y.size() ; i++)
      AddOp::bwd(*(y.data()+i), *(x1.data()+i), *(x2.data()+i));
  }


// SubOp (unary operations)

  Interval SubOp::fwd(const Interval& x1)
  {
    return -x1;
  }

  void SubOp::bwd(const Interval& y, Interval& x1)
  {
    Interval x2_(0.);
    bwd_sub(y, x2_, x1);
  }

  IntervalVector SubOp::fwd(const IntervalVector& x1)
  {
    return -x1;
  }

  void SubOp::bwd(const IntervalVector& y, IntervalVector& x1)
  {
    assert(y.size() == x1.size());
    for(Index i = 0 ; i < y.size() ; i++)
      bwd(y[i], x1[i]);
  }

  IntervalMatrix SubOp::fwd(const IntervalMatrix& x1)
  {
    return -x1;
  }

  void SubOp::bwd(const IntervalMatrix& y, IntervalMatrix& x1)
  {
    assert(y.size() == x1.size());
    for(Index i = 0 ; i < y.size() ; i++)
      SubOp::bwd(*(y.data()+i), *(x1.data()+i));
  }


// SubOp (binary operations)

  Interval SubOp::fwd(const Interval& x1, const Interval& x2)
  {
    return x1 - x2;
  }

  void SubOp::bwd(const Interval& y, Interval& x1, Interval& x2)
  {
    bwd_sub(y, x1, x2);
  }

  IntervalVector SubOp::fwd(const IntervalVector& x1, const IntervalVector& x2)
  {
    assert(x1.size() == x2.size());
    return x1 - x2;
  }

  void SubOp::bwd(const IntervalVector& y, IntervalVector& x1, IntervalVector& x2)
  {
    assert(y.size() == x1.size() && y.size() == x2.size());
    for(Index i = 0 ; i < y.size() ; i++)
      bwd(y[i], x1[i], x2[i]);
  }

  IntervalMatrix SubOp::fwd(const IntervalMatrix& x1, const IntervalMatrix& x2)
  {
    assert(x1.size() == x2.size());
    return x1 - x2;
  }

  void SubOp::bwd(const IntervalMatrix& y, IntervalMatrix& x1, IntervalMatrix& x2)
  {
    assert(y.size() == x1.size() && y.size() == x2.size());
    for(Index i = 0 ; i < y.size() ; i++)
      SubOp::bwd(*(y.data()+i), *(x1.data()+i), *(x2.data()+i));
  }


// MulOp

  Interval MulOp::fwd(const Interval& x1, const Interval& x2)
  {
    return x1 * x2;
  }

  void MulOp::bwd(const Interval& y, Interval& x1, Interval& x2)
  {
    bwd_mul(y, x1, x2);
  }

  IntervalVector MulOp::fwd(const Interval& x1, const IntervalVector& x2)
  {
    return x1 * x2;
  }

  void MulOp::bwd(const IntervalVector& y, Interval& x1, IntervalVector& x2)
  {
    assert(y.size() == x2.size());
    for(Index i = 0 ; i < x2.size() ; i++)
      bwd_mul(y[i], x1, x2[i]);
  }

  IntervalVector MulOp::fwd(const IntervalVector& x1, const Interval& x2)
  {
    return MulOp::fwd(x2,x1);
  }

  void MulOp::bwd(const IntervalVector& y, IntervalVector& x1, Interval& x2)
  {
    MulOp::bwd(y, x2, x1);
  }

  Interval MulOp::fwd(const IntervalRow& x1, const IntervalVector& x2)
  {
    assert(x1.size() == x2.size());
    Interval s(0.);
    for(Index i = 0 ; i < x1.size() ; i++)
      s += x1[i]*x2[i];
    return s;
  }

  void MulOp::bwd(const Interval& y, IntervalRow& x1, IntervalVector& x2)
  {
    assert(x1.size() == x2.size());

    const Index n = x1.size();
    vector<Interval> sums(n), prods(n);

    // Forward propagation

      for(Index i = 0 ; i < n ; i++)
      {
        prods[i] = x1[i]*x2[i];
        sums[i] = prods[i];
        if(i > 0) sums[i] += sums[i-1];
      }

    // Backward propagation

      sums[n-1] &= y;

      for(Index i = n-1 ; i >= 0 ; i--)
      {
        if(i > 0) AddOp::bwd(sums[i],sums[i-1],prods[i]);
        else prods[0] &= sums[0];
        MulOp::bwd(prods[i],x1[i],x2[i]);
      }
  }

  IntervalVector MulOp::fwd(const IntervalMatrix& x1, const IntervalVector& x2)
  {
    assert(x1.cols() == x2.size());
    return x1 * x2;
  }

  #include "codac2_linear_ctc.h"
  #include "codac2_GaussJordan.h"

  //#include "codac2_ibex.h"

  void MulOp::bwd(const IntervalVector& y, IntervalMatrix& x1, IntervalVector& x2)
  {
    assert(x1.rows() == y.size());
    assert(x1.cols() == x2.size());

    /*if(x1.is_squared()) // not working for any squared x1
    {
      CtcGaussElim ctc_ge;
      CtcLinearPrecond ctc_gep(ctc_ge);
      IntervalVector y_(y);
      ctc_gep.contract(x1,x2,y_);
    }*/

    if(x1.rows() > x1.cols())
    {
      #if 0 // IBEX version
        ibex::IntervalVector ibex_y(to_ibex(y)), ibex_x2(to_ibex(x2));
        ibex::IntervalMatrix ibex_x1(to_ibex(x1));
        ibex::bwd_mul(ibex_y, ibex_x1, ibex_x2, 0.05);
        x1 &= to_codac(ibex_x1);
        x2 &= to_codac(ibex_x2);
      #else

      Index last_row = 0;
      Index i = 0;

      do
      {
        double vol_x2 = x2.volume();
        IntervalRow row_i = x1.row(i);
        MulOp::bwd(y[i],row_i,x2);

        if(row_i.is_empty())
        {
          x1.set_empty();
          return;
        }

        else
          x1.row(i) = row_i;

        if(x2.volume()/vol_x2 < 0.98)
          last_row = i;
        i = (i+1)%y.size();
      } while(i != last_row);

      #endif
    }

    else
    {
      IntervalMatrix Q = gauss_jordan(x1.mid());
      IntervalVector b_tilde = Q*y;
      IntervalMatrix A_tilde = Q*x1; // should be a tree matrix

      for(int a = 0 ; a < 1 ; a++)
      {
        for(Index i = 0 ; i < x2.size() ; i++)
        {
          for(Index k = 0 ; k < b_tilde.size() ; k++)
          {
            Interval u = b_tilde[k];

            for(Index j = 0 ; j < x2.size() ; j++)
              if(i != j)
                u -= x2[j]*A_tilde(k,j);

            MulOp::bwd(u, x2[i], A_tilde(k,i));
          }
        }
      }
    }
  }


// DivOp

  Interval DivOp::fwd(const Interval& x1, const Interval& x2)
  {
    return x1 / x2;
  }

  void DivOp::bwd(const Interval& y, Interval& x1, Interval& x2)
  {
    bwd_div(y, x1, x2);
  }

  IntervalVector DivOp::fwd(const IntervalVector& x1, const Interval& x2)
  {
    return x1 / x2;
  }

  void DivOp::bwd(const IntervalVector& y, IntervalVector& x1, Interval& x2)
  {
    assert(x1.size() == y.size());
    for(Index i = 0 ; i < x1.size() ; i++)
      bwd_div(y[i], x1[i], x2);
  }


// PowOp

  Interval PowOp::fwd(const Interval& x1, const Interval& x2)
  {
    return pow(x1,x2);
  }

  void PowOp::bwd(const Interval& y, Interval& x1, Interval& x2)
  {
    bwd_pow(y, x1, x2);
  }


// SqrOp

  Interval SqrOp::fwd(const Interval& x1)
  {
    return sqr(x1);
  }

  void SqrOp::bwd(const Interval& y, Interval& x1)
  {
    bwd_sqr(y, x1);
  }


// SqrtOp

  Interval SqrtOp::fwd(const Interval& x1)
  {
    return sqrt(x1);
  }

  void SqrtOp::bwd(const Interval& y, Interval& x1)
  {
    bwd_sqrt(y, x1);
  }


// ExpOp

  Interval ExpOp::fwd(const Interval& x1)
  {
    return exp(x1);
  }

  void ExpOp::bwd(const Interval& y, Interval& x1)
  {
    bwd_exp(y, x1);
  }


// LogOp

  Interval LogOp::fwd(const Interval& x1)
  {
    return log(x1);
  }

  void LogOp::bwd(const Interval& y, Interval& x1)
  {
    bwd_log(y, x1);
  }


// CosOp

  Interval CosOp::fwd(const Interval& x1)
  {
    return cos(x1);
  }

  void CosOp::bwd(const Interval& y, Interval& x1)
  {
    bwd_cos(y, x1);
  }


// SinOp

  Interval SinOp::fwd(const Interval& x1)
  {
    return sin(x1);
  }

  void SinOp::bwd(const Interval& y, Interval& x1)
  {
    bwd_sin(y, x1);
  }


// TanOp

  Interval TanOp::fwd(const Interval& x1)
  {
    return tan(x1);
  }

  void TanOp::bwd(const Interval& y, Interval& x1)
  {
    bwd_tan(y, x1);
  }


// AcosOp

  Interval AcosOp::fwd(const Interval& x1)
  {
    return acos(x1);
  }

  void AcosOp::bwd(const Interval& y, Interval& x1)
  {
    bwd_acos(y, x1);
  }


// AsinOp

  Interval AsinOp::fwd(const Interval& x1)
  {
    return asin(x1);
  }

  void AsinOp::bwd(const Interval& y, Interval& x1)
  {
    bwd_asin(y, x1);
  }


// AtanOp

  Interval AtanOp::fwd(const Interval& x1)
  {
    return atan(x1);
  }

  void AtanOp::bwd(const Interval& y, Interval& x1)
  {
    bwd_atan(y, x1);
  }


// Atan2Op

  Interval Atan2Op::fwd(const Interval& x1, const Interval& x2)
  {
    return atan2(x1,x2);
  }

  void Atan2Op::bwd(const Interval& y, Interval& x1, Interval& x2)
  {
    bwd_atan2(y, x1, x2);
  }


// CoshOp

  Interval CoshOp::fwd(const Interval& x1)
  {
    return cosh(x1);
  }

  void CoshOp::bwd(const Interval& y, Interval& x1)
  {
    bwd_cosh(y, x1);
  }


// SinhOp

  Interval SinhOp::fwd(const Interval& x1)
  {
    return sinh(x1);
  }

  void SinhOp::bwd(const Interval& y, Interval& x1)
  {
    bwd_sinh(y, x1);
  }


// TanhOp

  Interval TanhOp::fwd(const Interval& x1)
  {
    return tanh(x1);
  }

  void TanhOp::bwd(const Interval& y, Interval& x1)
  {
    bwd_tanh(y, x1);
  }


// AbsOp

  Interval AbsOp::fwd(const Interval& x1)
  {
    return abs(x1);
  }

  void AbsOp::bwd(const Interval& y, Interval& x1)
  {
    bwd_abs(y, x1);
  }


// ComponentOp

  Interval ComponentOp::fwd(const IntervalVector& x1, Index i)
  {
    assert(i >= 0 && i < x1.size());
    return x1[i];
  }

  void ComponentOp::bwd(const Interval& y, IntervalVector& x1, Index i)
  {
    assert(i >= 0 && i < x1.size());
    x1[i] &= y;
  }


// SubvectorOp

  IntervalVector SubvectorOp::fwd(const IntervalVector& x1, Index i, Index j)
  {
    assert(i >= 0 && i < x1.size() && j >= i && j < x1.size());
    return x1.subvector(i,j);
  }

  void SubvectorOp::bwd(const IntervalVector& y, IntervalVector& x1, Index i, Index j)
  {
    assert(i >= 0 && i < x1.size() && j >= i && j < x1.size());
    assert(j-i < y.size());
    for(Index k = 0 ; k < j-i+1 ; k++)
      x1[i+k] &= y[k];
  }


// MatrixOp

  void MatrixOp::fwd_i(IntervalMatrix& m, const IntervalVector& x, Index i)
  {
    assert(i >= 0 && i < m.cols());
    m.resize(x.size(),m.cols());
    m.col(i) = x;
  }


// DetOp

  // For matrices

  Interval DetOp::fwd(const IntervalMatrix& x)
  {
    assert_release(x.is_squared() && "can only compute determinants for a square matrix");
    assert_release((x.rows() == 1 || x.rows() == 2) && "determinant not yet computable for n×n matrices, n>2");

    if(x.rows() == 1) // 1×1 matrix
      return x(0,0);

    else if(x.rows() == 2) // 2×2 matrix
      return x(0,0)*x(1,1)-x(0,1)*x(1,0);

    else
      return Interval::empty(); // unhandled case
  }

  void DetOp::bwd(const Interval& y, IntervalMatrix& x)
  {
    assert_release(x.is_squared() && "can only compute determinants for a square matrix");
    assert_release((x.rows() == 1 || x.rows() == 2) && "determinant not yet computable for n×n matrices, n>2");

    if(x.rows() == 1) // 1×1 matrix
      x(0,0) &= y;

    else if(x.rows() == 2) // 2×2 matrix
    {
      Interval z1 = x(0,0)*x(1,1), z2 = x(1,0)*x(0,1);
      SubOp::bwd(y, z1, z2);
      MulOp::bwd(z1, x(0,0), x(1,1));
      MulOp::bwd(z2, x(1,0), x(0,1));
    }

    else
    {
      // unhandled case
    }
  }

  // For two vectors (merged into a 2×2 matrix)

  Interval DetOp::fwd(const IntervalVector& x1, const IntervalVector& x2)
  {
    assert_release(x1.size() == 2 && x2.size() == 2 && "determinant only computable for pairs of 2d vectors");
    IntervalMatrix m(2,2);
    m.col(0) = x1; m.col(1) = x2;
    return DetOp::fwd(m);
  }

  void DetOp::bwd(const Interval& y, IntervalVector& x1, IntervalVector& x2)
  {
    assert_release(x1.size() == 2 && x2.size() == 2 && "determinant only computable for pairs of 2d vectors");
    IntervalMatrix m(2,2);
    m.col(0) = x1; m.col(1) = x2;
    DetOp::bwd(y,m);
    x1 &= m.col(0);
    x2 &= m.col(1);
  }

  // For three vectors (merged into a 3×3 matrix)

  Interval DetOp::fwd(const IntervalVector& x1, const IntervalVector& x2, const IntervalVector& x3)
  {
    assert_release(x1.size() == 3 && x2.size() == 3 && x3.size() == 3 && "determinant only computable for triplet of 3d vectors");
    IntervalMatrix m(3,3);
    m.col(0) = x1; m.col(1) = x2; m.col(2) = x3;
    return DetOp::fwd(m);
  }

  void DetOp::bwd(const Interval& y, IntervalVector& x1, IntervalVector& x2, IntervalVector& x3)
  {
    assert_release(x1.size() == 3 && x2.size() == 3 && x3.size() == 3 && "determinant only computable for triplet of 3d vectors");
    
    IntervalMatrix m(3,3);
    m.col(0) = x1; m.col(1) = x2; m.col(2) = x3;

    DetOp::bwd(y,m);
    x1 &= m.col(0);
    x2 &= m.col(1);
    x3 &= m.col(2);
  }