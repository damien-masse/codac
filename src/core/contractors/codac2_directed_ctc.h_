/** 
 *  \file codac2_directed_ctc.h
 * ----------------------------------------------------------------------------
 *  \date       2024
 *  \author     Simon Rohou
 *  \copyright  Copyright 2024 Codac Team
 *  \license    GNU Lesser General Public License (LGPL)
 */

#pragma once

#include <string>
#include "codac2_AnalyticType.h"
#include "codac2_template_tools.h"
#include "codac2_IntervalRow.h"

namespace codac2
{
  struct AddOp
  {
    // Unary operations
    static Interval fwd(const Interval& x1);
    static void bwd(const Interval& y, Interval& x1);

    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1)
    {
      if constexpr(NATURAL_EVAL)
        return {
          fwd(x1.a),
          x1.def_domain
        };

      else
        return {
          fwd(x1.m),
          fwd(x1.a),
          x1.da,
          x1.def_domain
        };
    }

    static IntervalVector fwd(const IntervalVector& x1);
    static void bwd(const IntervalVector& y, IntervalVector& x1);

    template<bool NATURAL_EVAL=false>
    static inline VectorType fwd(const VectorType& x1)
    {
      if constexpr(NATURAL_EVAL)
        return {
          fwd(x1.a),
          x1.def_domain
        };

      else
        return {
          fwd(x1.m),
          fwd(x1.a),
          x1.da,
          x1.def_domain
        };
    }

    static IntervalMatrix fwd(const IntervalMatrix& x1);
    static void bwd(const IntervalMatrix& y, IntervalMatrix& x1);

    template<bool NATURAL_EVAL=false>
    static inline MatrixType fwd(const MatrixType& x1)
    {
      if constexpr(NATURAL_EVAL)
        return {
          fwd(x1.a),
          x1.def_domain
        };

      else
        return {
          fwd(x1.m),
          fwd(x1.a),
          IntervalMatrix(0,0), // not supported yet for matrices
          x1.def_domain
        };
    }

    // Binary operations

    static Interval fwd(const Interval& x1, const Interval& x2);
    static void bwd(const Interval& y, Interval& x1, Interval& x2);

    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1, const ScalarType& x2)
    {
      if constexpr(NATURAL_EVAL)
        return {
          fwd(x1.a, x2.a),
          x1.def_domain && x2.def_domain
        };

      else
      {
        assert(x1.da.size() == x2.da.size());
        return {
          fwd(x1.m, x2.m),
          fwd(x1.a, x2.a),
          x1.da + x2.da,
          x1.def_domain && x2.def_domain
        };
      }
    }

    static IntervalVector fwd(const IntervalVector& x1, const IntervalVector& x2);
    static void bwd(const IntervalVector& y, IntervalVector& x1, IntervalVector& x2);

    template<bool NATURAL_EVAL=false>
    static inline VectorType fwd(const VectorType& x1, const VectorType& x2)
    {
      if constexpr(NATURAL_EVAL)
        return {
          fwd(x1.a, x2.a),
          x1.def_domain && x2.def_domain
        };

      else
      {
        assert(x1.da.rows() == x2.da.rows() && x1.da.cols() == x2.da.cols());
        return {
          fwd(x1.m, x2.m),
          fwd(x1.a, x2.a),
          x1.da + x2.da,
          x1.def_domain && x2.def_domain
        };
      }
    }

    static IntervalMatrix fwd(const IntervalMatrix& x1, const IntervalMatrix& x2);
    static void bwd(const IntervalMatrix& y, IntervalMatrix& x1, IntervalMatrix& x2);

    template<bool NATURAL_EVAL=false>
    static inline MatrixType fwd(const MatrixType& x1, const MatrixType& x2)
    {
      if constexpr(NATURAL_EVAL)
        return {
          fwd(x1.a, x2.a),
          x1.def_domain && x2.def_domain
        };

      else
        return {
          fwd(x1.m, x2.m),
          fwd(x1.a, x2.a),
          IntervalMatrix(0,0), // not supported yet for matrices
          x1.def_domain && x2.def_domain
        };
    }
  };

  struct SubOp
  {
    // Unary operations
    static Interval fwd(const Interval& x1);
    static void bwd(const Interval& y, Interval& x1);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1)
    {
      return {
        fwd(x1.m),
        fwd(x1.a),
        -x1.da,
        x1.def_domain
      };
    }

    static IntervalVector fwd(const IntervalVector& x1);
    static void bwd(const IntervalVector& y, IntervalVector& x1);
    
    template<bool NATURAL_EVAL=false>
    static inline VectorType fwd(const VectorType& x1)
    {
      return {
        fwd(x1.m),
        fwd(x1.a),
        -x1.da,
        x1.def_domain
      };
    }

    static IntervalMatrix fwd(const IntervalMatrix& x1);
    static void bwd(const IntervalMatrix& y, IntervalMatrix& x1);
    
    template<bool NATURAL_EVAL=false>
    static inline MatrixType fwd(const MatrixType& x1)
    {
      return {
        fwd(x1.m),
        fwd(x1.a),
        IntervalMatrix(0,0), // not supported yet for matrices
        x1.def_domain
      };
    }

    // Binary operations
    static Interval fwd(const Interval& x1, const Interval& x2);
    static void bwd(const Interval& y, Interval& x1, Interval& x2);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1, const ScalarType& x2)
    {
      assert(x1.da.rows() == x2.da.rows() && x1.da.cols() == x2.da.cols());
      return {
        fwd(x1.m, x2.m),
        fwd(x1.a, x2.a),
        x1.da - x2.da,
        x1.def_domain && x2.def_domain
      };
    }

    static IntervalVector fwd(const IntervalVector& x1, const IntervalVector& x2);
    static void bwd(const IntervalVector& y, IntervalVector& x1, IntervalVector& x2);
    
    template<bool NATURAL_EVAL=false>
    static inline VectorType fwd(const VectorType& x1, const VectorType& x2)
    {
      assert(x1.da.rows() == x2.da.rows() && x1.da.cols() == x2.da.cols());
      return {
        fwd(x1.m, x2.m),
        fwd(x1.a, x2.a),
        x1.da - x2.da,
        x1.def_domain && x2.def_domain
      };
    }

    static IntervalMatrix fwd(const IntervalMatrix& x1, const IntervalMatrix& x2);
    static void bwd(const IntervalMatrix& y, IntervalMatrix& x1, IntervalMatrix& x2);
    
    template<bool NATURAL_EVAL=false>
    static inline MatrixType fwd(const MatrixType& x1, const MatrixType& x2)
    {
      assert(x1.a.cols() == x2.a.cols() && x1.a.rows() == x2.a.rows());
      return {
        fwd(x1.m, x2.m),
        fwd(x1.a, x2.a),
        IntervalMatrix(0,0), // not supported yet for matrices
        x1.def_domain && x2.def_domain
      };
    }
  };

  struct MulOp
  {
    static Interval fwd(const Interval& x1, const Interval& x2);
    static void bwd(const Interval& y, Interval& x1, Interval& x2);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1, const ScalarType& x2)
    {
      assert(x1.da.rows() == 1);
      assert(x1.da.rows() == x2.da.rows() && x1.da.cols() == x2.da.cols());

      IntervalMatrix d(1,x1.da.cols());
      for(Index i = 0 ; i < d.size() ; i++)
        d(0,i) = x1.da(0,i)*x2.a + x1.a*x2.da(0,i);

      return {
        fwd(x1.m, x2.m),
        fwd(x1.a, x2.a),
        d,
        x1.def_domain && x2.def_domain
      };
    }

    static IntervalVector fwd(const Interval& x1, const IntervalVector& x2);
    static void bwd(const IntervalVector& y, Interval& x1, IntervalVector& x2);
    
    template<bool NATURAL_EVAL=false>
    static inline VectorType fwd(const ScalarType& x1, const VectorType& x2)
    {
      assert(x1.da.rows() == 1);
      assert(x1.da.cols() == x2.da.cols());
      assert(x2.a.size() == x2.da.rows());

      IntervalMatrix d(x2.da.rows(),x2.da.cols());
      for(Index i = 0 ; i < d.rows() ; i++)
        for(Index j = 0 ; j < d.cols() ; j++)
          d(i,j) = x1.da(0,j)*x2.a[i]+x1.a*x2.da(i,j);
      
      return {
        fwd(x1.m, x2.m),
        fwd(x1.a, x2.a),
        d,
        x1.def_domain && x2.def_domain
      };
    }

    static IntervalVector fwd(const IntervalVector& x1, const Interval& x2);
    static void bwd(const IntervalVector& y, IntervalVector& x1, Interval& x2);
    
    template<bool NATURAL_EVAL=false>
    static inline VectorType fwd(const VectorType& x1, const ScalarType& x2)
    {
      return MulOp::fwd(x2,x1);
    }

    static Interval fwd(const IntervalRow& x1, const IntervalVector& x2);
    static void bwd(const Interval& y, IntervalRow& x1, IntervalVector& x2);
    //template<bool NATURAL_EVAL=false>
    //static inline ScalarType fwd(const RowType& x1, const VectorType& x2); // RowType not yet defined

    static IntervalVector fwd(const IntervalMatrix& x1, const IntervalVector& x2);
    static void bwd(const IntervalVector& y, IntervalMatrix& x1, IntervalVector& x2);
    
    template<bool NATURAL_EVAL=false>
    static inline VectorType fwd(const MatrixType& x1, const VectorType& x2)
    {
      return {
        fwd(x1.a, /* <<----- x1.m */ x2.m),
        fwd(x1.a, x2.a),
        IntervalMatrix::zero(x1.a.rows(),x1.a.cols()), // todo
        x1.def_domain && x2.def_domain
      };
    }
  };

  struct DivOp
  {
    static Interval fwd(const Interval& x1, const Interval& x2);
    static void bwd(const Interval& y, Interval& x1, Interval& x2);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1, const ScalarType& x2)
    {
      assert(x1.da.size() == x2.da.size());

      IntervalMatrix d(1,x1.da.size());
      for(Index i = 0 ; i < d.size() ; i++)
        d(0,i) = (x1.da(0,i)*x2.a-x1.a*x2.da(0,i))/sqr(x2.a);

      return {
        fwd(x1.m, x2.m),
        fwd(x1.a, x2.a),
        d,
        x1.def_domain && x2.def_domain && x2.a != 0. /* def domain of the derivative of div */
      };
    }

    static IntervalVector fwd(const IntervalVector& x1, const Interval& x2);
    static void bwd(const IntervalVector& y, IntervalVector& x1, Interval& x2);
    
    template<bool NATURAL_EVAL=false>
    static inline VectorType fwd(const VectorType& x1, const ScalarType& x2)
    {
      assert(x1.da.size() == x2.da.size());

      IntervalMatrix d(1,x1.da.size());
      assert_release(false && "not implemented yet");

      return {
        fwd(x1.m, x2.m),
        fwd(x1.a, x2.a),
        d,
        x1.def_domain && x2.def_domain && x2.a != 0. /* def domain of the derivative of div */
      };
    }
  };

  struct PowOp
  {
    static Interval fwd(const Interval& x1, const Interval& x2);
    static void bwd(const Interval& y, Interval& x1, Interval& x2);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1, const ScalarType& x2)
    {
      IntervalMatrix d(1,x1.da.size());
      for(Index i = 0 ; i < d.size() ; i++)
        d(0,i) = x2.a*x1.da(0,i)*pow(x1.a,x2.a-1.);

      return {
        fwd(x1.m, x2.m),
        fwd(x1.a, x2.a),
        d,
        x1.def_domain && x2.def_domain
      };
    }
  };

  struct SqrOp
  {
    static Interval fwd(const Interval& x1);
    static void bwd(const Interval& y, Interval& x1);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1)
    {
      assert(x1.da.rows() == 1);

      IntervalMatrix d(1,x1.da.cols());
      for(Index i = 0 ; i < d.size() ; i++)
        d(0,i) = 2.*x1.a*x1.da(0,i);

      return {
        fwd(x1.m),
        fwd(x1.a),
        d,
        x1.def_domain
      };
    }
  };

  struct SqrtOp
  {
    static Interval fwd(const Interval& x1);
    static void bwd(const Interval& y, Interval& x1);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1)
    {
      IntervalMatrix d(1,x1.da.size());
      for(Index i = 0 ; i < d.size() ; i++)
        d(0,i) = x1.da(0,i)/(2.*sqrt(x1.a));

      return {
        fwd(x1.m),
        fwd(x1.a),
        d,
        x1.a.is_subset({0,oo}) /* def domain of sqrt */
        && x1.a != 0. /* def domain of the derivative of sqrt */
        && x1.def_domain
      };
    }
  };

  struct ExpOp
  {
    static Interval fwd(const Interval& x1);
    static void bwd(const Interval& y, Interval& x1);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1)
    {
      IntervalMatrix d(1,x1.da.size());
      for(Index i = 0 ; i < d.size() ; i++)
        d(0,i) = x1.da(0,i)*exp(x1.a);

      return {
        fwd(x1.m),
        fwd(x1.a),
        d,
        x1.def_domain
      };
    }
  };

  struct LogOp
  {
    static Interval fwd(const Interval& x1);
    static void bwd(const Interval& y, Interval& x1);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1)
    {
      IntervalMatrix d(1,x1.da.size());
      for(Index i = 0 ; i < d.size() ; i++)
        d(0,i) = x1.da(0,i)/x1.a;

      return {
        fwd(x1.m),
        fwd(x1.a),
        d,
        x1.a.is_subset({0,oo}) /* def domain of log */
        && x1.a != 0. /* def domain of the derivative of log */
        && x1.def_domain
      };
    }
  };

  struct CosOp
  {
    static Interval fwd(const Interval& x1);
    static void bwd(const Interval& y, Interval& x1);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1)
    {
      IntervalMatrix d(1,x1.da.size());
      for(Index i = 0 ; i < d.size() ; i++)
        d(0,i) = -sin(x1.a)*x1.da(0,i);

      return {
        fwd(x1.m),
        fwd(x1.a),
        d,
        x1.def_domain
      };
    }
  };

  struct SinOp
  {
    static Interval fwd(const Interval& x1);
    static void bwd(const Interval& y, Interval& x1);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1)
    {
      IntervalMatrix d(1,x1.da.size());
      for(Index i = 0 ; i < d.size() ; i++)
        d(0,i) = cos(x1.a)*x1.da(0,i);

      return {
        fwd(x1.m),
        fwd(x1.a),
        d,
        x1.def_domain
      };
    }
  };

  struct TanOp
  {
    static Interval fwd(const Interval& x1);
    static void bwd(const Interval& y, Interval& x1);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1)
    {
      IntervalMatrix d(1,x1.da.size());
      for(Index i = 0 ; i < d.size() ; i++)
        d(0,i) = x1.da(0,i)/sqr(cos(x1.a));

      return {
        fwd(x1.m),
        fwd(x1.a),
        d,
        x1.def_domain && cos(x1.a) != 0. /* def domain of the derivative of tan */
      };
    }
  };

  struct AcosOp
  {
    static Interval fwd(const Interval& x1);
    static void bwd(const Interval& y, Interval& x1);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1)
    {
      IntervalMatrix d(1,x1.da.size());
      for(Index i = 0 ; i < d.size() ; i++)
        d(0,i) = -x1.da(0,i)/sqrt(1.-sqr(x1.a));

      return {
        fwd(x1.m),
        fwd(x1.a),
        d,
        x1.a.is_subset({-1,1}) /* def domain of acos */
        && x1.a != 1. /* def domain of the derivative of acos */
        && x1.def_domain
      };
    }
  };

  struct AsinOp
  {
    static Interval fwd(const Interval& x1);
    static void bwd(const Interval& y, Interval& x1);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1)
    {
      IntervalMatrix d(1,x1.da.size());
      for(Index i = 0 ; i < d.size() ; i++)
        d(0,i) = x1.da(0,i)/sqrt(1.-sqr(x1.a));

      return {
        fwd(x1.m),
        fwd(x1.a),
        d,
        x1.a.is_subset({-1,1}) /* def domain of asin */
        && x1.a != 1. /* def domain of the derivative of asin */
        && x1.def_domain
      };
    }
  };

  struct AtanOp
  {
    static Interval fwd(const Interval& x1);
    static void bwd(const Interval& y, Interval& x1);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1)
    {
      IntervalMatrix d(1,x1.da.size());
      for(Index i = 0 ; i < d.size() ; i++)
        d(0,i) = x1.da(0,i)/(1.+sqr(x1.a));

      return {
        fwd(x1.m),
        fwd(x1.a),
        d,
        x1.def_domain
      };
    }
  };

  struct Atan2Op
  {
    static Interval fwd(const Interval& x1, const Interval& x2);
    static void bwd(const Interval& y, Interval& x1, Interval& x2);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1, const ScalarType& x2)
    {
      assert(x1.da.rows() == 1);
      assert(x1.da.rows() == x2.da.rows() && x1.da.cols() == x2.da.cols());

      IntervalMatrix d(1,x1.da.cols());
      for(Index i = 0 ; i < d.size() ; i++)
        d(0,i) = (-x1.a*x2.da(0,i)/(sqr(x2.a)+sqr(x1.a)))+(x2.a*x1.da(0,i)/(sqr(x2.a)+sqr(x1.a)));

      return {
        fwd(x1.m, x2.m),
        fwd(x1.a, x2.a),
        d,
        x1.def_domain && x2.def_domain
        && !(x1.a == 0. && x2.a == 0.) /* def domain of the derivative of atan2 */
      };
    }
  };

  struct CoshOp
  {
    static Interval fwd(const Interval& x1);
    static void bwd(const Interval& y, Interval& x1);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1)
    {
      IntervalMatrix d(1,x1.da.size());
      for(Index i = 0 ; i < d.size() ; i++)
        d(0,i) = sinh(x1.a)*x1.da(0,i);

      return {
        fwd(x1.m),
        fwd(x1.a),
        d,
        x1.def_domain
      };
    }
  };

  struct SinhOp
  {
    static Interval fwd(const Interval& x1);
    static void bwd(const Interval& y, Interval& x1);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1)
    {
      IntervalMatrix d(1,x1.da.size());
      for(Index i = 0 ; i < d.size() ; i++)
        d(0,i) = cosh(x1.a)*x1.da(0,i);

      return {
        fwd(x1.m),
        fwd(x1.a),
        d,
        x1.def_domain
      };
    }
  };

  struct TanhOp
  {
    static Interval fwd(const Interval& x1);
    static void bwd(const Interval& y, Interval& x1);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1)
    {    
      IntervalMatrix d(1,x1.da.size());
      for(Index i = 0 ; i < d.size() ; i++)
        d(0,i) = x1.da(0,i)/sqr(cosh(x1.a));

      return {
        fwd(x1.m),
        fwd(x1.a),
        d,
        x1.def_domain
      };
    }
  };

  struct AbsOp
  {
    static Interval fwd(const Interval& x1);
    static void bwd(const Interval& y, Interval& x1);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const ScalarType& x1)
    {
      IntervalMatrix d(1,x1.da.size());
      for(Index i = 0 ; i < d.size() ; i++)
        d(0,i) = (x1.a/abs(x1.a))*x1.da(0,i);

      return {
        fwd(x1.m),
        fwd(x1.a),
        d,
        x1.def_domain && x1.a != 0. /* def domain of the derivative of abs */
      };
    }
  };

  struct ComponentOp
  {
    static Interval fwd(const IntervalVector& x1, Index i);
    static void bwd(const Interval& y, IntervalVector& x1, Index i);

    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const VectorType& x1, Index i)
    {
      assert(i >= 0 && i < x1.a.rows());

      if constexpr(NATURAL_EVAL)
        return {
          fwd(x1.a,i),
          x1.def_domain
        };

      else
        return {
          fwd(x1.m,i),
          fwd(x1.a,i),
          x1.da.row(i),
          x1.def_domain
        };
    }
  };

  struct SubvectorOp
  {
    static IntervalVector fwd(const IntervalVector& x1, Index i, Index j);
    static void bwd(const IntervalVector& y, IntervalVector& x1, Index i, Index j);

    template<bool NATURAL_EVAL=false>
    static inline VectorType fwd(const VectorType& x1, Index i, Index j)
    {
      assert(i >= 0 && i < x1.a.rows() && j >= i && j < x1.a.rows());

      if constexpr(NATURAL_EVAL)
        return {
          fwd(x1.a,i,j),
          x1.def_domain
        };

      else
        return {
          fwd(x1.m,i,j),
          fwd(x1.a,i,j),
          x1.da.block(i,0,j-i+1,x1.da.cols()),
          x1.def_domain
        };
    }
  };

  struct VectorOp
  {
    template<typename... X>
      requires (std::is_base_of_v<Interval,X> && ...)
    static IntervalVector fwd(const X&... x)
    {
      return IntervalVector({x...});
    }

    template<typename... X>
      requires (std::is_base_of_v<Interval,X> && ...)
    static void bwd(const IntervalVector& y, X&... x)
    {
      Index i = 0;
      ((x &= y[i++]), ...);
    }

    template<bool NATURAL_EVAL,typename... X>
      requires (std::is_base_of_v<ScalarType,X> && ...)
    static inline VectorType fwd(const X&... x)
    {
      IntervalMatrix d(sizeof...(X),std::get<0>(std::tie(x...)).da.cols());
      Index i = 0;
      ((d.row(i++) = x.da), ...);

      bool def_domain = true;
      ((def_domain &= x.def_domain), ...);
      
      return {
        fwd(x.m...),
        fwd(x.a...),
        d,
        def_domain
      };
    }
  };

  struct MatrixOp
  {
    static void fwd_i(IntervalMatrix& m, const IntervalVector& x, Index i);

    template<typename... X>
      requires (std::is_base_of_v<Domain,X> && ...)
    static IntervalMatrix fwd(const X&... x)
    {
      throw std::runtime_error("MatrixOp not fully implemented yet");
      IntervalMatrix m(1, sizeof...(X));
      Index i = 0;
      (MatrixOp::fwd_i(m, x, i++), ...);
      return m;
    }

    template<typename... X>
      requires (std::is_base_of_v<IntervalVector,X> && ...)
    static void bwd(const IntervalMatrix& y, X&... x)
    {
      throw std::runtime_error("MatrixOp not fully implemented yet");
      Index i = 0;
      ((x &= y.col(i++)), ...);
    }

    template<bool NATURAL_EVAL,typename... X>
      requires (std::is_base_of_v<VectorType,X> && ...)
    static inline MatrixType fwd(const X&... x)
    {
      throw std::runtime_error("MatrixOp not fully implemented yet");
      return {
        IntervalMatrix({x.m...}),
        IntervalMatrix({x.a...}),
        IntervalMatrix(0,0), // not supported yet for matrices
        true // todo with variadic
      };
    }
  };

  struct DetOp
  {
    // For matrices
    static Interval fwd(const IntervalMatrix& x);
    static void bwd(const Interval& y, IntervalMatrix& x);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const MatrixType& x)
    {
      if(NATURAL_EVAL)
        return {
          fwd(x.a),
          x.def_domain
        };

      else
        return {
          fwd(x.m),
          fwd(x.a),
          IntervalMatrix(0,0), // not supported yet for auto diff
          x.def_domain
        };
    }

    // For two vectors (merged into a 2×2 matrix)
    static Interval fwd(const IntervalVector& x1, const IntervalVector& x2);
    static void bwd(const Interval& y, IntervalVector& x1, IntervalVector& x2);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const VectorType& x1, const VectorType& x2)
    {
      IntervalMatrix a(2,2);
      a.col(0) = x1.a; a.col(1) = x2.a;

      if constexpr(NATURAL_EVAL)
        return {
          fwd(a),
          x1.def_domain && x2.def_domain
        };

      else
      {
        IntervalMatrix m(2,2);
        m.col(0) = x1.m; m.col(1) = x2.m;

        return {
          fwd(m),
          fwd(a),
          IntervalMatrix(0,0), // not supported yet for auto diff
          x1.def_domain && x2.def_domain
        };
      }
    }

    // For three vectors (merged into a 3×3 matrix)
    static Interval fwd(const IntervalVector& x1, const IntervalVector& x2, const IntervalVector& x3);
    static void bwd(const Interval& y, IntervalVector& x1, IntervalVector& x2, IntervalVector& x3);
    
    template<bool NATURAL_EVAL=false>
    static inline ScalarType fwd(const VectorType& x1, const VectorType& x2, const VectorType& x3)
    {
      IntervalMatrix a(3,3);
      a.col(0) = x1.a; a.col(1) = x2.a; a.col(2) = x3.a;

      if constexpr(NATURAL_EVAL)
        return {
          fwd(a),
          x1.def_domain && x2.def_domain && x3.def_domain
        };

      else
      {
        IntervalMatrix m(3,3);
        m.col(0) = x1.m; m.col(1) = x2.m; m.col(2) = x3.m;

        return {
          fwd(m),
          fwd(a),
          IntervalMatrix(0,0), // not supported yet for auto diff
          x1.def_domain && x2.def_domain && x3.def_domain
        };
      }
    }
  };
}